[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Processing"})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@4db568e1, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/karanshah/CSE562/kshah23/src/main/scala/microbase/Microbase.scala","languageId":"scala","version":1,"text":"package microbase \nimport java.io.File\nimport util.control.Breaks._\nimport scala.io._\nimport scala.io.StdIn.readLine\nimport org.apache.spark.unsafe.types.UTF8String\nimport org.apache.spark.sql.execution.SparkSqlParser\nimport org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\nimport org.apache.spark.sql.catalyst.plans.logical.CreateTableStatement\nimport org.apache.spark.sql.types._\nimport org.apache.spark.sql.catalyst.analysis.UnresolvedRelation\nimport org.apache.spark.sql.catalyst.plans.logical.LeafNode\nimport org.apache.spark.sql.catalyst.expressions.AttributeSeq\nimport org.apache.spark.sql.catalyst.expressions.Attribute\nimport org.apache.commons.lang3.ObjectUtils\nimport org.apache.spark.sql.catalyst.analysis.UnresolvedStar\nimport org.apache.spark.sql.catalyst.expressions.AttributeReference\nimport MyTable._\nimport TableIterator._\nimport org.apache.spark.sql.catalyst.analysis.UnresolvedAttribute\nimport org.apache.spark.sql.catalyst.plans.logical.Project\nimport scala.collection.mutable.ArrayStack\nimport org.apache.spark.sql.catalyst.expressions.NamedExpression\nimport org.apache.spark.sql.catalyst.plans.logical.Filter\nimport org.apache.spark.sql.catalyst.InternalRow\nimport org.apache.spark.sql.catalyst.plans.logical.Join\nimport org.apache.spark.sql.catalyst.expressions.EqualTo\nimport org.apache.spark.sql.catalyst.expressions\nimport org.apache.spark.sql.catalyst.expressions.Expression\nimport org.apache.spark.sql.catalyst.plans.NaturalJoin\nimport org.apache.spark.sql.catalyst.plans.Inner\nimport org.apache.spark.sql.internal.SQLConf\nimport org.apache.spark.sql.catalyst.expressions.BoundReference\nimport org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, ExprCode}\nimport org.apache.spark.sql.catalyst.plans.logical.Union\nimport org.apache.spark.sql.catalyst.analysis.UnresolvedAlias\nimport org.apache.spark.sql.catalyst.expressions.Alias\nimport org.apache.spark.sql.catalyst.plans.logical.SubqueryAlias\nimport org.apache.spark.sql.catalyst.plans.logical.Subquery\nimport org.apache.spark.sql.catalyst.expressions.JoinedRow\nimport org.apache.spark.sql.catalyst.plans.logical.Sort\nimport _root_.org.apache.spark.sql.catalyst.expressions.SortOrder\nimport org.apache.spark.sql.catalyst.plans.logical.Limit\nimport org.apache.spark.sql.catalyst.plans.logical.GlobalLimit\nimport org.apache.spark.sql.catalyst.plans.logical.LocalLimit\nimport org.apache.spark.sql.catalyst.expressions.Literal\n\nobject Microbase\n{\n    //CREATE TABLE R(A int, B int, C int) USING csv OPTIONS(path 'data/R.data', delimiter'|');\n    //CREATE TABLE S(A int, L int, M int) USING csv OPTIONS(path 'data/S.data', delimiter'|');\n    //CREATE TABLE T(L int, X int, Y int) USING csv OPTIONS(path 'data/S.data', delimiter'|');\n\n    def main(args:Array[String]):Unit=\n    { \n        var tableRef = scala.collection.mutable.HashMap[Seq[String],MyTable]()\n        var input:String=\"\"\n        var logical_plan:LogicalPlan=null;\n        var resolvedRelation:LogicalPlan=null;\n        def parseSql(sql: String): LogicalPlan =  new SparkSqlParser().parsePlan(sql)\n        def bindReferences(expression:Expression , child:LogicalPlan) : Expression =\n        {\n            bindReference(expression,child.output)\n        }\n        def bindReference(expression:Expression , input : Seq[Attribute]) : Expression =\n        {\n            val inputPosition = input.map(_.exprId).zipWithIndex.toMap\n            expression.transformDown\n            {\n                case attrRef: AttributeReference =>\n                {\n                    BoundReference(inputPosition(attrRef.exprId),attrRef.dataType,attrRef.nullable)\n                }\n            }\n        }\n        def compare(a:InternalRow,b:InternalRow,order:Seq[SortOrder]) : Boolean=\n        {\n            false\n        }\n        def startEval(logical_plan : LogicalPlan) : Iterator[InternalRow] =\n        {\n            logical_plan match \n            {\n                case Project(projectList, child)=> \n                {\n                    var childIterator : Iterator[InternalRow] = startEval(child)\n                    val compiledExprs = projectList.map(bindReferences(_,child))\n                    ProjectIterator(compiledExprs,childIterator)\n                }\n                case Filter(condition, child) =>\n                 {\n                     var childIterator : Iterator[InternalRow] = startEval(child)\n                     var boundCondition : Expression = bindReferences(condition,child)\n                     FilterIterator(boundCondition,childIterator)\n                 }\n                case MyTable(tableName, tableSchema, location) => \n                {\n                    TableIterator(tableSchema,location)\n                }\n                case Union(children:Seq[LogicalPlan],_,_)=>\n                {\n                    val childIterator=children.map(startEval(_))\n                    val firstIterator=childIterator.head\n                    val secondIterator=childIterator.tail.head\n                    UnionIterator(firstIterator,secondIterator)\n                }\n                case SubqueryAlias(identifier,child)=>\n                {\n                    startEval(child)\n                }\n                case subplan:Subquery => startEval(subplan.children(0))\n                case Sort(order,global,child)=>\n                {\n                    var childIterator=startEval(child).toSeq\n                    println(\"Order: \"+order)\n                    var x=childIterator.sortWith((a,b)=>compare(a,b,order))\n                    println(\"x=\"+x)\n                    childIterator.iterator\n                }\n                case GlobalLimit(limitExpr,child)=>\n                {\n                    var childIterator=startEval(child).slice(0,limitExpr.toString().toInt) \n                    childIterator\n                }\n                case LocalLimit(limitExpr,child)=>\n                {\n                    var childIterator=startEval(child).slice(0,limitExpr.toString().toInt) \n                    childIterator\n                }\n                case Join(left,right,joinType,condition,hint) => \n                {\n                    var leftChildIterator : Iterator[InternalRow] = startEval(left)\n                    var rightChildIterator = startEval(right).toSeq\n                    leftChildIterator.flatMap \n                    { \n                        leftRow => \n                        rightChildIterator.map \n                        { \n                            rightRow => \n                            new JoinedRow(leftRow, rightRow)\n                        }\n                    }\n                }\n\n            }\n        } \n        def resolveProject(projectList:Seq[NamedExpression],child:LogicalPlan):Seq[NamedExpression]=\n        { \n            var newList:Seq[NamedExpression] = Seq[NamedExpression]()\n            for(x <- projectList)\n            {\n                x match {\n                    case UnresolvedStar(target) => \n                    {\n                        if(target==None)\n                        {\n                            newList = newList ++ child.output\n                        }\n                        else\n                        {\n                            for(y <- child.output)\n                            {\n                                if (target.get(0).equals(y.qualifier.head))\n                                {\n                                    newList = newList :+ y\n                                }\n                            }\n                        }\n                    }\n                    case UnresolvedAttribute(nameParts) => \n                    {\n                        for(y <- child.output)\n                        {\n                            if(x.name.equals(y.name) || x.name.equals(y.qualifiedName))\n                            {\n                                newList = newList :+ y\n                            }\n                        }\n                    }\n                    case UnresolvedAlias(childExp,aliasFunc)=>\n                    {\n                        var ChildExp=childExp.transformUp\n                        {\n                            case UnresolvedAttribute(nameParts) => \n                            {\n                                var newAttribute = scala.collection.mutable.ArrayBuffer.empty[Attribute]\n                                for(z <- child.output)\n                                {\n                                    if (nameParts.last.equals(z.name))\n                                    {\n                                        newAttribute.append(z)\n                                    }\n                                }\n                                newAttribute.head\n                            }\n                        }\n                        var name=\"\"\n                        var newALias= Alias(ChildExp,name)()\n                        newList=  newList :+ newALias\n                    }\n                    case Alias(childExp, name) => \n                    {\n                       var ChildExp=childExp.transformUp\n                        {\n                            case UnresolvedAttribute(nameParts) => \n                            {\n                                 var newAttribute = scala.collection.mutable.ArrayBuffer.empty[Attribute]\n                                    for(z <- child.output)\n                                    {\n                                        if (nameParts.last.equals(z.name))//|| nameParts(0).equals(z.qualifier.head))\n                                        {\n                                            if(nameParts.length>1 && nameParts(0).equals(z.qualifier.head))\n                                            {\n                                                newAttribute.append(z)\n                                            }\n                                            else\n                                            {\n                                                newAttribute.append(z)\n                                            }\n                                            \n                                        }\n                                    }\n                                    newAttribute.head\n                            }\n                        }\n                        var newALias= Alias(ChildExp,name)()\n                        newList=  newList :+ newALias\n                    }\n                }\n            }\n            newList\n        }\n        while(true)\n        {\n            println(\"$>\")\n            input=readLine()\n            logical_plan=parseSql(input)\n            print(logical_plan.treeString)\n            \n            logical_plan match\n            {\n                case c: CreateTableStatement =>\n                {\n                    /* do something with c.name, c.tableSchema */\n                    var tableobj= new MyTable(c.tableName,c.tableSchema,c.location)\n                    tableRef += (c.tableName -> tableobj)\n                }\n                \n                case _ =>/* Interpret plan like a query */\n                {\n                    logical_plan = logical_plan.transform\n                    {\n                        case UnresolvedRelation(nameElements, _, _) =>\n                        {  \n                            tableRef(nameElements)\n                        }\n                    }\n                    \n                    logical_plan = logical_plan.transformUp\n                    {    \n                        case Project(projectList,child)=>\n                        {   var temp:LogicalPlan=null\n                            var newList = resolveProject(projectList,child)\n                            temp=Project(newList,child)\n                            temp\n                        }\n                        case Filter(condition, child) => \n                        {\n                            var Condition=condition.transformUp\n                            {\n                                case UnresolvedAttribute(nameParts)=>\n                                {\n                                    var newAttribute = scala.collection.mutable.ArrayBuffer.empty[Attribute]\n                                    for(z <- child.output)\n                                    {\n                                        if(nameParts.length>1)\n                                        {\n                                            if(nameParts(0).equals(z.qualifier.head))\n                                            {\n                                                newAttribute.append(z)\n                                            }\n                                        }\n                                        else if (nameParts.last.equals(z.name))\n                                        {\n                                            newAttribute.append(z)\n                                        }                                     \n                                    }\n                                    newAttribute.head\n                                }\n                            }\n                            Filter(Condition,child)\n                        }       \n                        case Join(left,right,joinType,condition,hint)=>\n                        {\n                        //    if (joinType.isInstanceOf(NaturalJoin))\n                        //    {\n                        //        Join(left,right,joinType=Inner,condition,hint)\n                        //    }\n                            if(condition.equals(None))\n                            {\n                                Join(left,right,joinType,condition,hint)\n                            }\n                            //Join(left,right,joinType,condition,hint)\n                            else\n                            {\n                                var Condition = condition.get.transformUp\n                                {\n                                    case UnresolvedAttribute(nameParts) => \n                                    {\n                                        var newAttribute = scala.collection.mutable.ArrayBuffer.empty[Attribute]\n                                        if(nameParts.head.equals(left.output(0).qualifier.head))\n                                        {\n                                            for(x <- left.output)\n                                            {\n                                                if (nameParts(0).equals(x.name) || nameParts(0).equals(x.qualifier.head))\n                                                {\n                                                    newAttribute.append(x)\n                                                }\n                                            } \n                                        }\n                                        if(nameParts.head.equals(right.output(0).qualifier.head))\n                                        {\n                                            for(x <- right.output)\n                                            {\n                                                if (nameParts(0).equals(x.name) || nameParts(0).equals(x.qualifier.head))\n                                                {\n                                                    newAttribute.append(x)\n                                                }\n                                            }                  \n                                        }\n                                        newAttribute.head\n                                    }\n                                }\n                                Join(left,right,joinType,new Some(Condition),hint)\n                            }\n                        }  \n                        case Sort(order,global,child)=>\n                        {\n                            var newOrder:Seq[SortOrder]=Seq[SortOrder]()\n                            for(eachOrder <- order)\n                            {\n                                //println(\"sortOrder expression: \"+eachOrder.child)\n                                var resolvedChild=eachOrder.child.transformUp\n                                {\n                                    case UnresolvedAttribute(nameParts) => \n                                    {\n                                        var newAttribute = scala.collection.mutable.ArrayBuffer.empty[Attribute]\n                                        for(z <- child.output)\n                                        {\n                                            if(nameParts.length>1)\n                                            {\n                                                if(nameParts(0).equals(z.qualifier.head))\n                                                {\n                                                    newAttribute.append(z)\n                                                }\n                                            }\n                                            else if (nameParts.last.equals(z.name))\n                                            {\n                                                newAttribute.append(z)\n                                            }                                     \n                                        }\n                                        newAttribute.head\n                                    }\n                                }\n                                newOrder=newOrder :+ SortOrder(resolvedChild,eachOrder.direction,eachOrder.nullOrdering,eachOrder.sameOrderExpressions)\n                            }\n                            Sort(newOrder,global,child)\n                        }\n                    }\n                }\n             }\n             if (logical_plan.resolved)\n             {\n                 //optimise(logical_plan)\n                 var iterator=startEval(logical_plan)\n                 while(iterator.hasNext)\n                 {\n                    val value=iterator.next()\n                    //println(value)\n                    breakable\n                    {\n                        if(value==null)\n                        {\n                            break\n                        }\n                        else\n                        {\n                            for(i<-0 to logical_plan.output.length-2)\n                            {\n                                print(value.get(i,logical_plan.output(i).dataType))\n                                print(\"|\")\n                            }\n                            print(value.get(logical_plan.output.length-1,logical_plan.output(logical_plan.output.length-1).dataType))\n                            //println(value)\n                            println()\n                        }\n                    }     \n                 }\n             }\n             println(logical_plan.treeString)\n             println(logical_plan.resolved)\n               \n         }\n    }\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/Users/karanshah/CSE562/kshah23/target/scala-2.12/zinc/inc_compile_2.12.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed 30 Mar 2022, 19:50:02[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Done"})[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, â™¨1, shutdown, null})[0m
